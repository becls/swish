% Copyright 2018 Beckman Coulter, Inc.
%
% Permission is hereby granted, free of charge, to any person
% obtaining a copy of this software and associated documentation files
% (the "Software"), to deal in the Software without restriction,
% including without limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of the Software,
% and to permit persons to whom the Software is furnished to do so,
% subject to the following conditions:
%
% The above copyright notice and this permission notice shall be
% included in all copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
% EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
% NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
% BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
% ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.

\chapter {Erlang Embedding}\label{chap:erlang}

\section {Introduction}

This chapter describes the design of the message-passing concurrency
model. It provides a Scheme embedding of a significant subset of the
Erlang programming
language~\cite{armstrong-thesis,programming-erlang}.\footnote{Tuples,
  denoted by \{$e_1$, \ldots, $e_n$\} in Erlang, are implemented as
  vectors: \code{\#(\var{e$_1$}~\etc~\var{e$_n$})}. Similarly
  records, defined as syntactic sugar over tuples in Erlang, are
  implemented as syntactic sugar over vectors.}  Tuple and pattern
matching macros provide succinct ways of composing and decomposing
data structures.

The basic unit of sequential computation is the \emph{process}.  Each
process has independent state and communicates with other processes by
message passing. Because processes share no mutable state, one process
cannot corrupt the state of another process---a problem that plagues
software using shared-state concurrency. \concern{System procedures that
  mutate data can cause state corruption.} \mitigation The code is
inspected for use of these procedures.

An uncaught exception in one process does not affect any other
process. A process can be monitored for termination, and it can be
linked to another process so that, when either process exits, the
other one receives an exit signal.  Processes are implemented with
one-shot continuations~\cite{one-shot}, and the concurrent system is
simulated by the single-threaded program using software
timer interrupts.  The operating system interface (see
Chapter~\ref{chap:osi}) provides asynchronous input/output (I/O) so
that processes waiting for I/O do not stop other processes from
executing.

For exceptions, we use Erlang's approach of encoding the information
in a machine-readable datum rather than a formatted string. Doing so
makes it possible to write code that matches particular exceptions
without having to parse strings, and the exception is human language
independent.

The rest of this chapter is organized as follows.
Section~\ref{sec:erlang-data-structures} introduces the main data structures,
Section~\ref{sec:erlang-theory} describes how the concurrency
model works, and Section~\ref{sec:erlang-api} gives the
programming interface.

\section {Data Structures}\label{sec:erlang-data-structures}

\paragraph {\code{q}}\index{q@\code{q}}
Queues are used in several key places: the inbox of messages for each
process, the list of processes ready to run, and the list of sleeping
processes. A \emph{queue} is a doubly-linked list with a sentinel
value, the queue's identity. Both the sentinel value and the elements
of the queue are instances of \code{q}, a Scheme record type with
mutable \code{prev} and \code{next} fields.  This representation
enables constant-time insertion and deletion operations.

\paragraph {\code{msg}}\index{msg@\code{msg}}
When a \emph{message} is sent to a process, its contents are wrapped
in an instance of \code{msg}, a Scheme record type that extends
\code{q} with an immutable \code{contents} field. This
\code{msg} is inserted into the process's inbox and removed when the
process receives it.

\paragraph {\code{pcb}}\index{pcb@\code{pcb}}
A \emph{process} is an instance of \code{pcb}, a Scheme record type
that extends \code{q} with an immutable \code{id} field, the process's
unique positive exact integer, an immutable \code{create-time} field,
the process's create time from \code{erlang:now}, and the following
mutable fields:
\begin{itemize}
\item \code{name}: registered name or \code{\#f}
\item \code{cont}: one-shot continuation if live and not currently
  running or \code{\#f} otherwise
\item \code{sic}: system interrupt count
\item \code{winders}: list of winders if live and not currently
  running or \code{()} otherwise
\item \code{exception-state}: exception state if live and not
  currently running, exit reason if dead, or \code{\#f} if currently
  running
\item \code{inbox}: queue of \code{msg} if live or \code{\#f} if
  dead
\item \code{precedence}: wake time if sleeping or 0 if ready to run
\item \code{flags}: fixnum with bit 0 set when sleeping, bit 1 set
  when the process traps exits, and bit 2 set when the process is
  blocked for I/O
\item \code{links}: list of linked processes
\item \code{monitors}: list of monitors
\item \code{src}: source location \code{\#(at \var{char-offset}
  \var{filename})} when available if waiting in a \code{receive}
  macro, a string if blocked for I/O, or \code{\#f}
\end{itemize}

\paragraph {\code{mon}}\index{mon@\code{mon}}
A \emph{monitor} is an instance of \code{mon}, a Scheme record type
with two immutable fields, \code{origin} and \code{target}, each
of which is a process.

\paragraph {\code{osi-port}}\index{osi-port@\code{osi-port}}
An \emph{osi-port} is an instance of \code{osi-port}, a Scheme record
type with an immutable \code{name} field, an immutable
\code{create-time} field, and a mutable \code{handle} field that wraps
an operating system interface port. The \code{handle} field is set to
\code{\#f} when the osi-port is closed.

\paragraph {\code{path-watcher}}\index{path-watcher@\code{path-watcher}}
A \emph{path watcher}\index{path watcher} is an instance of
\code{path-watcher}, a Scheme record type with an immutable
\code{path} field, an immutable \code{create-time} field, and a
mutable \code{handle} field. The \code{handle} field is set to
\code{\#f} when the path watcher is closed.

\paragraph {\code{listener}}\index{listener@\code{listener}}
A \emph{TCP listener}\index{TCP listener} is an instance of
\code{listener}, a Scheme record type with immutable \code{address},
\code{port-number}, and \code{create-time} fields and a mutable
\code{handle} field. The \code{handle} field is set to \code{\#f} when
the listener is closed.

\section {Theory of Operation}\label{sec:erlang-theory}

The system uses a \emph{scheduler}\index{scheduler} to execute one
process at a time. Each process holds its own system interrupt count
(updated by \code{enable-interrupts} and \code{disable-interrupts}),
list of winders (maintained by \code{dynamic-wind} and the system
primitive \code{\$current-winders}), and exception state (maintained
by \code{current-exception-state}). The scheduler captures the
one-shot continuation for a process with an empty list of winders so
that, when it invokes the continuation of another process, it does not
run any winders. \concern{Using a system procedure that relies on the
  global winders list may lead to incorrect behavior.} \mitigation
System procedures that rely on the global winders list are called from
only one process at a time using the
\emph{gatekeeper}\index{gatekeeper} described in
Chapter~\ref{chap:gatekeeper}. The gatekeeper hooks the \code{\$cp0},
\code{\$np-compile}, \code{pretty-print}, and \code{sc-expand} system
primitives.

Spawning a new process is not as simple as capturing a one-shot
continuation and creating a \code{pcb} record, because the
continuation's stack link~\cite{representing-control} would be the
continuation of the caller, and its list of winders would be the
caller's. Thus, the scheduler remembers the current list of winders
and then sets it to the empty list before capturing a one-shot
continuation.  This return continuation is stored in a mutable
variable so that it is not closed over by the new process.  Next, a
full continuation is captured to create the initial exception state
that will terminate the new process when an uncaught exception is
raised. So that this full continuation does not refer to the caller's
continuation, the current stack link is set to the null continuation
before capturing it. After capturing the full continuation, a one-shot
continuation for the new process is captured and returned to the
caller via the return continuation.

Each process runs until it waits in a \code{receive} macro or
\code{wait-for-io} procedure, is preempted by the
\code{timer-interrupt-handler}, or exits.  The operating system
interface (see Chapter~\ref{chap:osi}) provides asynchronous I/O
operations so that the scheduler can execute other processes while the
system is performing I/O.  The timer interrupt handler runs every 1000
procedure calls.\footnote{1000 was chosen because Chez Scheme performs
  its internal interrupt checks every 1000 ticks.} The scheduler uses
\code{osi\_set\_tick} and \code{osi\_is\_tick\_over} to determine when
the time quantum for a process has elapsed.

When process \var{p} exits with reason \var{r}, the message
\code{\#(DOWN \var{m} \var{p} \var{r})} is sent to each of its
monitor \var{m}'s \code{origin} processes.  The message
\code{\#(EXIT \var{p} \var{r})} is sent to each linked process that
traps exits. If \var{r} is not \code{normal}, each linked process
that does not trap exits is killed with reason \var{r}.

A process can be registered with a global name, a symbol. This name
can be used instead of the process record itself to send it messages.
A global \emph{registrar}\index{registrar} maintains an eq-hashtable
mapping names to processes. The reverse mapping is maintained in the
\code{pcb} record through the \code{name} field.

There are two system processes: the
\emph{event-loop}\index{event-loop} and the
\emph{finalizer}\index{finalizer}.

The event-loop process calls \code{osi\_get\_callbacks} to retrieve
callback lists from the operating system interface.  It executes each
callback with interrupts disabled.  Event-loop callbacks are designed
to execute quickly without failing or causing new completion packets
to be enqueued. Typical callbacks register objects that wrap operating
system interface handles with a guardian and send messages to a
process. If the event-loop process exits with reason $r$, the system
logs the event \code{\#(event-loop-process-terminated $r$)} with
\code{console-event-handler} and calls \code{osi\_exit} with exit code
80.

The scheduler maintains the \emph{run queue}\index{run queue}, a queue
of ready-to-run processes, and the \emph{sleep queue}\index{sleep
  queue}, a queue of sleeping processes. Both are ordered by
increasing precedence and preserve the order of insertion for
processes with the same precedence. For the run queue, each process
has precedence 0 in order to implement round-robin scheduling. For the
sleep queue, each process uses its wake time as the precedence.

When the run queue is empty, the event-loop process calls
\code{osi\_get\_callbacks} with a non-zero timeout based on the first
entry in the sleep queue to avoid busy waiting. When the event-loop
process finishes processing all completion packets, it places itself
at the end of the run queue.

\concern{Some process may starve another process.}  \mitigation The
run queue is managed with round-robin scheduling to prevent
starvation. The event-loop process does not starve other processes
because it drains the completion queue without causing new completion
packets to be enqueued.

The finalizer process\label{finalizer-process} runs the finalizers
registered via \code{add-finalizer}. These finalizers typically close
operating system interface handles to objects that are no longer
accessible. \concern{Ill-behaved finalizers may cause memory and
  handle leaks.}  \mitigation Finalizers are designed to execute
quickly without failing. Typical finalizers guard against errors when
closing handles. If the finalizer process exits with reason $r$, the
system logs the event \code{\#(finalizer-process-terminated $r$)} with
\code{console-event-handler} and calls \code{osi\_exit} with exit code
80.

Once the finalizer process runs all the finalizers, it waits until
another garbage collection has occurred before running again. The
system hooks the \code{collect} procedure so that
it sends a wake-up message to the finalizer process every time a
garbage collection occurs.  When the finalizer receives the wake-up
message, it pumps all other wake-up messages from its inbox, since
there may have been more than one garbage collection since it last
ran.

Asynchronous I/O operations for COM ports, named pipes, external
operating system processes, files, console input, and TCP connections
are implemented with custom binary ports so that they have the same
interface as the system I/O procedures. The system I/O procedures are
not used because they perform synchronous I/O.  The custom port buffer
size is set to 1024\footnote{1024 was chosen because Chez Scheme uses
  1024 for the buffer size of buffered transcoded ports.} with
\code{custom-port-buffer-size}.  The custom binary port read and write
procedures call \code{osi\_read\_port} and \code{osi\_write\_port}
with callbacks that send a message to the calling process, which waits
until it receives the message.

\concern{Using a port from more than one process at the same time may
  cause errors including buffer corruption.}  \mitigation The code is
inspected for concurrent use of ports. Port visibility is typically
limited to a single process.

For two-way communication ports, we use two custom ports: one
exclusively for input, and one exclusively for output. We do not use
custom input/output ports for two reasons.  First, textual
input/output ports created with \code{transcoded-port} are not safe
to use from two concurrent processes because one transcoding buffer is
used for both reading and writing.  Second, the input side of a port
is commonly used only by a reader process, and the output side of a
port is commonly used only by a writer process.  Keeping the input and
output sides separate prevents concurrent use. The underlying handle
is closed when the output port is closed.

\concern{Failing to close a handle from the operating system interface
  that is no longer used causes resource leaks.}  \mitigation An
\emph{osi-port guardian}\index{osi-port guardian} and associated
finalizer are used to identify and close inaccessible osi-ports using
\code{osi\_close\_port}. A \emph{path-watcher
  guardian}\index{path-watcher guardian} and associated finalizer
are used to identify and close inaccessible path
watchers\index{path watcher}.  A \emph{listener
  guardian}\index{listener guardian} and associated finalizer are used
to identify and close inaccessible TCP listeners\index{TCP
  listener}. In all cases, interrupts are disabled around code that
wraps handles and registers objects with guardians in order to prevent
the current process from being killed during this critical time.

\section {Programming Interface}\label{sec:erlang-api}

% ----------------------------------------------------------------------------
\subsection {Process Creation}

% ----------------------------------------------------------------------------
\defineentry{spawn}
\begin{procedure}
  \code{(spawn \var{thunk})}
\end{procedure}
\returns{} a process

The \code{spawn} procedure creates and returns a new process that
executes \var{thunk}, a procedure of no arguments. The new process
starts with \code{name} = \code{\#f}, \code{sic} = 0 (interrupts
enabled), \code{winders} = \code{()}, an \code{exception-state}
that terminates the process on an unhandled exception, an empty
\code{inbox}, \code{precedence} = 0, \code{flags} = 0 (the
process is not sleeping and does not trap exits), \code{links} =
\code{()}, \code{monitors} = \code{()}, and \code{src} =
\code{\#f}.

% ----------------------------------------------------------------------------
\defineentry{spawn\&link}
\begin{procedure}
  \code{(spawn\&link \var{thunk})}
\end{procedure}
\returns{} a process

Like \code{spawn}, the \code{spawn\&link} procedure creates and
returns a new process that executes \var{thunk}. In addition, it links
the new process to the calling process.

% ----------------------------------------------------------------------------
\subsection {Process Registration}

% ----------------------------------------------------------------------------
\defineentry{get-registered}
\begin{procedure}
  \code{(get-registered)}
\end{procedure}
\returns{} a list of registered process names

The \code{get-registered} procedure returns a list of currently
registered process names from the registrar.

% ----------------------------------------------------------------------------
\defineentry{register}
\begin{procedure}
  \code{(register \var{name} \var{process})}
\end{procedure}
\returns{} \code{\#t}

The \code{register} procedure adds \var{name} $\rightarrow$
\var{process} to the registrar and sets \var{process}.\code{name} =
\var{name}. When a registered process exits, its registration is
removed. If \var{name} is not a symbol, exception \code{\#(bad-arg
  register \var{name})} is raised. If \var{process} is not a process,
exception \code{\#(bad-arg register \var{process})} is raised. If
\var{process} is dead, exception \code{\#(process-dead \var{process})}
is raised. If \var{process} is already registered to name $n$,
exception \code{\#(process-already-registered $n$)} is raised. If
\var{name} is already registered to process $p$, exception
\code{\#(name-already-registered $p$)} is raised.

% ----------------------------------------------------------------------------
\defineentry{unregister}
\begin{procedure}
  \code{(unregister \var{name})}
\end{procedure}
\returns{} \code{\#t}

The \code{unregister} procedure removes \var{name} $\rightarrow$
\var{process} from the registrar and sets \var{process}.\code{name}
= \code{\#f}.  If \var{name} is not registered, exception
\code{\#(bad-arg unregister \var{name})} is raised.

% ----------------------------------------------------------------------------
\defineentry{whereis}
\begin{procedure}
  \code{(whereis \var{name})}
\end{procedure}
\returns{} a process \alt{} \code{\#f}

The \code{whereis} procedure returns the process associated with
\var{name} or \code{\#f} if \var{name} is not registered.  If
\var{name} is not a symbol, exception \code{\#(bad-arg whereis
  \var{name})} is raised.

% ----------------------------------------------------------------------------
\subsection {Process Termination, Links, and Monitors}

% ----------------------------------------------------------------------------
\defineentry{catch}
\begin{syntax}
  \code{(catch \var{e1} \var{e2} \etc{})}
\end{syntax}
\expandsto{}\begin{alltt}\antipar
(call/1cc
 (lambda (return)
   (with-exception-handler
    (lambda (reason) (return `#(EXIT ,reason)))
    (lambda () \var{e1} \var{e2} \etc{}))))\end{alltt}

The \code{catch} macro evaluates expressions \var{e1} \var{e2}
\etc{} in a dynamic context that traps exceptions.  If no exception is
raised, the return value is the value of the last expression. If
exception \var{reason} is raised, \code{\#(EXIT \var{reason})} is
returned.

% ----------------------------------------------------------------------------
\defineentry{demonitor}
\begin{procedure}
  \code{(demonitor \var{monitor})}
\end{procedure}
\returns{} \code{\#t}

The \code{demonitor} procedure removes a \var{monitor} created by
the calling process (\var{self}) from \var{self}.\code{monitors} and
\var{monitor}.\code{target}.\code{monitors} if present.  If
\var{monitor} is not a monitor with \code{origin} = \var{self},
exception \code{\#(bad-arg demonitor \var{monitor})} is raised.

% ----------------------------------------------------------------------------
\defineentry{demonitor\&flush}
\begin{procedure}
  \code{(demonitor\&flush \var{monitor})}
\end{procedure}
\returns{} \code{\#t}

The \code{demonitor\&flush} procedure provides a convenient way to
demonitor and flush any remaining \code{DOWN} message from the
calling process's \code{inbox}. It performs the following operations:
\antipar\begin{alltt}
(demonitor \var{monitor})
(receive (until 0 #t)
  [#(DOWN ,@\var{monitor} ,_ ,_) #t])
\end{alltt}

% ----------------------------------------------------------------------------
\defineentry{kill}
\begin{procedure}
  \code{(kill \var{process} \var{reason})}
\end{procedure}
\returns{} \code{\#t}

The \code{kill} procedure is used to terminate a process.
\begin{enumerate}
\item If \var{process} is not a process, exception \code{\#(bad-arg kill
  \var{process})} is raised.
\item If \var{process} has already exited, nothing happens.
\item If \var{reason} is \code{kill}, \var{process} is terminated
  with reason \code{killed}, even if it traps exits.
\item If \var{process} traps exits, message \code{\#(EXIT \var{self}
  \var{reason})} is sent to \var{process}, where \var{self} is the
  calling process.
\item If \var{process} does not trap exits and \var{reason} is
  \code{normal}, nothing happens.
\item Otherwise, \var{process} is terminated with \var{reason}.
\end{enumerate}

% ----------------------------------------------------------------------------
\defineentry{link}
\begin{procedure}
  \code{(link \var{process})}
\end{procedure}
\returns{} \code{\#t}

The \code{link} procedure creates a bi-directional link between the
calling process (\var{self}) and \var{process}. No more than one link
can exist between two processes, but it is not an error to call
\code{link} more than once on the same two processes.

\begin{enumerate}
\item If \var{process} is not a process, exception \code{\#(bad-arg link
  \var{process})} is raised.
\item If \var{process} is \var{self}, nothing happens.
\item If \var{process} has not exited, then if the two processes are
  already linked, nothing happens; otherwise, \var{self} is added to
  \var{process}.\code{links}, and \var{process} is added to
  \var{self}.\code{links}.
\item Otherwise, \var{process} has exited with reason $r$ =
  \var{process}.\code{exception-state}.
  \begin{enumerate}
  \item If \var{self} traps exits, message \code{\#(EXIT \var{process} $r$)}
    is sent to \var{self}.
  \item If \var{self} does not trap exits and \var{reason} is \code{normal},
    nothing happens.
  \item Otherwise, \var{self} is terminated with reason $r$.
  \end{enumerate}
\end{enumerate}

% ----------------------------------------------------------------------------
\defineentry{monitor}
\begin{procedure}
  \code{(monitor \var{process})}
\end{procedure}
\returns{} a monitor

The \code{monitor} procedure creates and returns a new monitor $m$
with \code{origin} = the calling process (\var{self}) and
\code{target} = \var{process}.  Unlike \code{link},
\code{monitor} can create more than one connection between the same
processes.  It adds $m$ to \var{self}.\code{monitors} and
\var{process}.\code{monitors}.  When \var{process} exits or has
already exited with reason $r$, the message \code{\#(DOWN $m$
  \var{process} $r$)} is sent to \var{self}.  If \var{process} is not
a process, exception \code{\#(bad-arg monitor \var{process})} is
raised.

% ----------------------------------------------------------------------------
\defineentry{monitor?}
\begin{procedure}
  \code{(monitor? \var{x})}
\end{procedure}
\returns{} a boolean

The \code{monitor?} procedure determines whether or not the datum
\var{x} is a monitor.

% ----------------------------------------------------------------------------
\defineentry{unlink}
\begin{procedure}
  \code{(unlink \var{process})}
\end{procedure}
\returns{} \code{\#t}

The \code{unlink} procedure removes the bi-directional link if
present between the calling process (\var{self}) and \var{process} by
removing \var{self} from \var{process}.\code{links} and
\var{process} from \var{self}.\code{links}.  If \var{process} is not
a process, exception \code{\#(bad-arg unlink \var{process})} is
raised.

% ----------------------------------------------------------------------------
\subsection {Messages and Pattern Matching}

The pattern matching syntax of Figure~\ref{fig:erlang-pattern-grammar}
provides a concise and expressive way to match data structures and
bind variables to parts. The \code{receive}, \code{match}, and
\code{match-let*} macros use this pattern language. The
implementation uses two structurally recursive passes over the
pattern. The first pass checks the pattern syntax including tuple
types and field names and accumulates the list of pattern
variables. This list enables it to check for duplicate pattern
variables.  The second pass emits code that matches the input against
the pattern left to right.

% ----------------------------------------------------------------------------
\begin{figure}
\begin{tabular}{lp{3.6in}}
  pattern & matches \\ \hline

  \var{symbol} & itself \\
  \var{number} & itself \\
  \var{boolean} & itself \\
  \var{character} & itself \\
  \var{string} & itself \\
  \var{bytevector} & itself \\

  \code{()} & itself \\
  \code{($p_1$ . $p_2$)} & a pair whose car matches $p_1$ and cdr
  matches $p_2$ \\

  \code{\#($p_1$ \etc{} $p_n$)} & a vector of $n$ elements whose
  elements match $p_1$ \etc{} $p_n$ \\

  \code{,\_} & any datum \\
  \code{,\var{variable}} & any datum and binds a fresh \var{variable} to it \\
  \code{,@\var{variable}} & any datum \code{equal?} to the bound
  \var{variable} \\

  \code{,(\var{variable} <= \var{pattern})} & any datum that
  matches \var{pattern} and binds a fresh \var{variable} to it \\

  \code{`(\var{type} \set{,\var{field}\alt{}[\var{field} \var{pattern}]} \etc{})} &
  an instance of the tuple \var{type}, each \var{field} of which is
  bound to fresh variable \var{field} or matches the corresponding
  \var{pattern} \\

  \hline
\end{tabular}
\caption{Pattern Grammar\label{fig:erlang-pattern-grammar}}
\end{figure}

% ----------------------------------------------------------------------------
\defineentry{match}
\begin{syntax}\begin{alltt}
(match \var{exp}
  (\nt{pattern} \opt{(guard \var{g})} \var{b1} \var{b2} \etc{})
  \etc{})\strut\end{alltt}
\end{syntax}
\returns{} the value of the last expression \var{b1} \var{b2} \etc{}
for the matched pattern

The \code{match} macro evaluates \var{exp} once and tests its value
$v$ against each pattern and optional guard.  Each guard expression
\var{g} is evaluated in the scope of its associated pattern
variables. When \var{g} returns \code{\#f}, $v$ fails to match that
clause.  For the first pattern and guard that matches $v$, the
expressions \var{b1} \var{b2} \etc{} are evaluated in the scope of its
pattern variables. If $v$ fails to match all patterns, exception
\code{\#(bad-match $v$ \var{src})} is raised, where \var{src} is the
source location of the \code{match} clause if available.

See Figure~\ref{fig:erlang-pattern-grammar} for the pattern grammar.

% ----------------------------------------------------------------------------
\defineentry{match-let*}
\begin{syntax}\begin{alltt}
(match-let* ([\nt{pattern} \opt{(guard \var{g})} \var{exp}]
             \etc{})
  \var{b1} \var{b2} \etc{})\strut\end{alltt}
\end{syntax}
\returns{} the value of the last expression \var{b1} \var{b2} \etc{}

The \code{match-let*} macro evaluates each \var{exp} in the order
specified and matches its value against its pattern and guard.  The
pattern variables of each clause extend the scope of its guard
expression \var{g} and all subsequent pattern clauses and body
expressions \var{b1} \var{b2} \etc{}.  The \code{match-let*} macro
returns the value of the last body expression.  If any pattern fails
to match or any \var{g} returns \code{\#f}, exception
\code{\#(bad-match $v$ \var{src})} is raised, where $v$ is the datum
that failed to match the pattern or guard at source location \var{src}
if available.

See Figure~\ref{fig:erlang-pattern-grammar} for the pattern grammar.

% ----------------------------------------------------------------------------
\defineentry{receive}
\begin{syntax}
  \begin{alltt}
(receive
  \opt{(after \var{timeout} \var{t1} \var{t2} \etc{})\alt{}(until \var{time} \var{t1} \var{t2} \etc{})}
  (\nt{pattern} \opt{(guard \var{g})} \var{b1} \var{b2} \etc{})
  \etc{})\strut\end{alltt}
\end{syntax}
\returns{} the value of the last evaluated expression

The \code{receive} macro examines each message $m$ in the calling
process's \code{inbox} by testing it against each pattern and
optional guard. Each guard expression \var{g} is evaluated in the
scope of its associated pattern variables.  When \var{g} returns
\code{\#f}, $m$ fails to match that clause.  For the first pattern
and guard that matches $m$, $m$ is removed from \code{inbox}, and
the expressions \var{b1} \var{b2} \etc{} are evaluated in the scope of
its pattern variables.  If $m$ fails to match all patterns, the
examination continues with the next message in \code{inbox}. When
all messages have been examined, the calling process waits with its
\code{src} field set to the source location of the \code{receive}
macro if available. The process awakens when a new message or the time
specified by the optional \code{after} or \code{until} clause
arrives. If a new message arrives before the timeout, the examination
process continues as before. Otherwise, the timeout expressions
\var{t1} \var{t2} \etc{} are evaluated.

The optional \code{after} clause specifies a \var{timeout} in
milliseconds from the time at which control enters the
\code{receive} macro.  Similarly, the optional \code{until}
clause specifies a clock \var{time} in milliseconds as measured by
\code{erlang:now}.  In addition, \var{timeout} and \var{time} can be
\code{infinity} to indicate no timeout. If $t$ = \var{timeout} or
\var{time} is not a non-negative exact integer or \code{infinity},
exception \code{\#(timeout-value $t$ \var{src})} is returned, where
\var{src} is the source location of the \code{receive} macro if
available.

See Figure~\ref{fig:erlang-pattern-grammar} for the pattern grammar.

% ----------------------------------------------------------------------------
\defineentry{send}
\begin{procedure}
  \code{(send \var{destination} \var{message})}
\end{procedure}
\returns{} \var{message}

The \code{send} procedure sends \var{message} to a process or
registered name, \var{destination}.  If \var{destination} is not a
process or registered name, exception \code{\#(bad-arg send
  \var{destination})} is raised.  If \var{destination} has exited,
nothing else happens.  Otherwise, \var{message} is added to the end of
\var{destination}.\code{inbox}.  If \var{destination} is sleeping, it
is awakened.  If \var{destination} is not blocked for I/O and not on
the run queue\index{run queue}, it is placed on the run queue with
precedence 0.

% ----------------------------------------------------------------------------
\subsection {Process Properties}

% ----------------------------------------------------------------------------
\defineentry{pps}
\begin{procedure}
  \code{(pps \opt{\var{op}})}
\end{procedure}
\returns{} unspecified

The \code{pps} procedure prints information about all processes to
textual output port \var{op}, which defaults to the current output
port. If \var{op} is not an output port, exception \code{\#(bad-arg
  pps \var{op})} is raised.

% ----------------------------------------------------------------------------
\defineentry{process?}
\begin{procedure}
  \code{(process? \var{x})}
\end{procedure}
\returns{} a boolean

The \code{process?} procedure determines whether or not the datum
\var{x} is a process.

% ----------------------------------------------------------------------------
\defineentry{process-id}
\begin{procedure}
  \code{(process-id \opt{\var{process}})}
\end{procedure}
\returns{} the process id

The \code{process-id} procedure returns \var{process}.\code{id},
where \var{process} defaults to \code{self}. If \var{process} is not
a process, exception \code{\#(bad-arg process-id \var{process})} is
raised.

% ----------------------------------------------------------------------------
\defineentry{process-trap-exit}
\begin{parameter}
  \code{process-trap-exit}
\end{parameter}
\hasvalue{} boolean

The \code{process-trap-exit} parameter specifies whether or not the
calling process traps exit signals as messages. Processes start with
this parameter set to \code{\#f}.

% ----------------------------------------------------------------------------
\defineentry{self}
\begin{syntax}
  \code{self}
\end{syntax}
\returns{} the current process

The \code{self} macro uses \code{identifier-syntax} to expand into
code that retrieves the global self variable's top-level value. The
global variable cannot be used directly because library bindings are
immutable.

% ----------------------------------------------------------------------------
\subsection{Miscellaneous}

% ----------------------------------------------------------------------------
\defineentry{add-finalizer}
\begin{procedure}
  \code{(add-finalizer \var{finalizer})}
\end{procedure}
\returns{} unspecified

The \code{add-finalizer}\index{finalizer} procedure adds
\var{finalizer} to the global list of finalizers. \var{finalizer} is a
procedure of no arguments that runs in the finalizer process after
garbage collections. If \var{finalizer} is not a procedure, exception
\code{\#(bad-arg add-finalizer \var{finalizer})} is raised.

% ----------------------------------------------------------------------------
\defineentry{bad-arg}
\begin{procedure}
  \code{(bad-arg \var{who} \var{arg})}
\end{procedure}
\returns{} never

The \code{bad-arg} procedure raises exception \code{\#(bad-arg
  \var{who} \var{arg})}.

% ----------------------------------------------------------------------------
\defineentry{complete-io}
\begin{procedure}
  \code{(complete-io \var{process})}
\end{procedure}
\returns{} unspecified

The \code{complete-io} procedure is used in callback functions to
unblock a \var{process} from a call to \code{wait-for-io}. If
\var{process} is not a process, exception \code{\#(bad-arg complete-io
  \var{process})} is raised.

% ----------------------------------------------------------------------------
\defineentry{console-event-handler}
\begin{procedure}
  \code{(console-event-handler \var{event})}
\end{procedure}
\returns{} unspecified

The \code{console-event-handler} procedure prints an \var{event} to
the console error port. It is used when the event manager is not
available. It disables interrupts so that it can be called from
multiple processes safely.  The output is designed to be machine
readable. The output looks like this:

\begin{alltt}
Date: Fri Aug 06 11:54:59 2010
Timestamp: 1281110099144
Event: \var{event}
\end{alltt}

The date is the local time from the \code{date-and-time} procedure,
the timestamp is the clock time from \code{erlang:now}, and
\var{event} is printed as with \code{write}.

% ----------------------------------------------------------------------------
\defineentry{dbg}
\begin{procedure}
  \code{(dbg)}\\
  \code{(dbg \var{id})}\\
  \code{(dbg \var{base} \var{proc})}\strut
\end{procedure}
\returns{} see below

The \code{dbg} procedure is used to debug processes that exit with a
continuation condition.

\code{(dbg)} prints to the current output port the process id and
exception message for each process that exited with a continuation
condition.

\code{(dbg \var{id})} enters the interactive debugger using the
exception state of process \var{id}. If process \var{id} does not
exist or did not exit with a continuation condition, the following
message is printed: ``Nothing to debug.''

\code{(dbg \var{base} \var{proc})} folds over the processes that
exited with a continuation condition and calls \var{proc} with the
process id, process exception state, and the accumulator value
(initially \var{base}). It returns the final accumulator value.

% ----------------------------------------------------------------------------
\defineentry{dump-stack}
\begin{procedure}
  \code{(dump-stack \opt{\var{op}})}\\
  \code{(dump-stack \var{k} \var{op} \var{max-depth})}\strut
\end{procedure}
\returns{} unspecified

The \code{dump-stack} procedure prints information about the stack up
to \var{max-depth} to textual output port \var{op}, which defaults to
the current output port.

\var{k} is a continuation, and \var{max-depth} is either the symbol
\code{default} or a positive fixnum. The default max-depth is 10.

\code{(dump-stack \var{op})} calls \code{(call/cc (lambda (\var{k})
  (dump-stack \var{k} \var{op} 'default)))}.

% ----------------------------------------------------------------------------
\defineentry{erlang:now}
\begin{procedure}
  \code{(erlang:now)}
\end{procedure}
\returns{} the current clock time in milliseconds

The \code{erlang:now} procedure calls \code{osi\_get\_time} to return
the number of milliseconds in UTC since the UNIX epoch January 1,
1970.

% -------------------------------------------------------------------------
\defineentry{make-process-parameter}
\begin{procedure}
  \code{(make-process-parameter \var{initial} \opt{\var{filter}})}
\end{procedure}
\returns{} a process parameter procedure

The \code{make-process-parameter} procedure creates a parameter
procedure $p$ that provides per-process, mutable storage using a weak
eq-hashtable mapping processes to values. Calling $p$ with no
arguments returns the current value of the parameter for the calling
process, and calling $p$ with one argument sets the value of the
parameter for the calling process. The \var{filter}, if present, is a
procedure of one argument that is applied to the \var{initial} and all
subsequent values. If \var{filter} is not a procedure, exception
\code{\#(bad-arg make-process-parameter \var{filter})} is raised.

The following system parameters are not process safe and have
been redefined to use \code{make-process-parameter}:
\code{custom-port-buffer-size},
\code{exit-handler},
\code{pretty-initial-indent},
\code{pretty-line-length},
\code{pretty-maximum-lines},
\code{pretty-one-line-limit},
\code{pretty-standard-indent},
\code{print-brackets},
\code{print-char-name},
\code{print-gensym},
\code{print-graph},
\code{print-length},
\code{print-level},
\code{print-precision},
\code{print-radix},
\code{print-record},
\code{print-unicode},
\code{print-vector-length},
\code{reset-handler}, and
\code{waiter-prompt-and-read}.

% -------------------------------------------------------------------------
\defineentry{on-exit}
\begin{syntax}
  \code{(on-exit \var{finally} \var{b1} \var{b2} \etc{})}
\end{syntax}
\expandsto{}\begin{alltt}\antipar
(dynamic-wind
  void
  (lambda () \var{b1} \var{b2} \etc{})
  (lambda () \var{finally}))\end{alltt}

The \code{on-exit} macro executes the body expressions \var{b1}
\var{b2} \etc{} in a dynamic context that executes the \var{finally}
expression whenever control leaves the body.

% ----------------------------------------------------------------------------
\defineentry{profile-me}
\begin{procedure}
  \code{(profile-me)}
\end{procedure}
\returns{} unspecified

The \code{profile-me} procedure does nothing but provide a
place-holder for the system profiler to count the call site. When
profiling is turned off, \code{(profile-me)} expands to
\code{(void)}, and the system optimizer eliminates it.

% ----------------------------------------------------------------------------
\defineentry{wait-for-io}
\begin{procedure}
  \code{(wait-for-io \var{name})}
\end{procedure}
\returns{} unspecified

The \code{wait-for-io} procedure blocks the current process for
I/O. The \var{name} string indicates the target of the I/O
operation. To unblock the process, call \code{complete-io} from a
callback function.

% ----------------------------------------------------------------------------
\subsection {Tuples}

For users of the concurrency model, a \emph{tuple}\index{tuple} is a
container of named, immutable fields implemented as a vector whose
first element is the tuple name and remaining elements are the
fields. Each tuple definition is a macro that provides all tuple
operations using field names only, not field indices. The macro makes
it easy to copy a tuple without having to specify the fields that
don't change.  We decided not to use the Scheme record facility
because it does not provide name-based constructors, copy operators,
or convenient serialization.

% ----------------------------------------------------------------------------
\index{tuple!define-tuple@\code{define-tuple}}
\defineentry{define-tuple}
\begin{syntax}
  \code{(define-tuple \var{name} \var{field} \etc{})}
\end{syntax}
\expandsto{} a macro definition of \var{name} described below

The \code{define-tuple} macro defines a macro for creating,
copying, identifying, and accessing tuple type \var{name}. \var{name}
and \var{field} \etc{} must be identifiers. No two field names can be
the same. The following field names are reserved: \code{make},
\code{copy}, \code{copy*}, and \code{is?}.

% ----------------------------------------------------------------------------
\index{tuple!make@\code{make}}
\begin{syntax}
  \code{(\var{name} make [\var{field} \var{value}] \etc{})}
\end{syntax}
\returns{} a new instance of tuple type \var{name} with \var{field} =
\var{value} \etc{}

The \code{make} form creates a new instance of the tuple type
\var{name}. \var{field} bindings may appear in any order. All fields
from the tuple definition must be specified.

% ----------------------------------------------------------------------------
\index{tuple!field accessor}
\begin{syntax}
  \code{(\var{name} \var{field} \var{instance})}
\end{syntax}
\returns{} \var{instance}.\var{field}

The field accessor form retrieves the value of the specified
\var{field} of \var{instance}. If $r$ = \var{instance} is not a tuple
of type \var{name}, exception \code{\#(bad-tuple \var{name} $r$
  \var{src})} is raised, where \var{src} is the source location of the
field accessor form if available.

\index{tuple!field accessor}
\begin{syntax}
  \code{(\var{name} \var{field})}
\end{syntax}
\returns{} a procedure that, given \var{instance}, returns \var{instance}.\var{field}

The \code{(\var{name} \var{field})} form expands to \code{(lambda (instance) (\var{name} \var{field} instance))}.

% ----------------------------------------------------------------------------
\index{tuple!open@\code{open}}
\begin{syntax}
  \code{(\var{name} open \var{instance} \opt{\var{prefix}} (\var{field} \etc{}))}
\end{syntax}
\expandsto{} definitions for \var{field} \etc{} or \var{prefix}\var{field} \etc{} described below

The \code{open} form defines identifier syntax for each specified \var{field}
so that a reference to \var{field} expands to \code{(\var{name} \var{field} $r$)}
where $r$ is the value of \var{instance}.
If $r$ is not a tuple of type \var{name}, exception
\code{\#(bad-tuple \var{name} $r$ \var{src})} is raised, where
\var{src} is the source location of the \code{open} form if avalable.
The \code{open} form is equivalent to the following, except that it
checks the tuple type only once:
\antipar\codebegin
(begin
  (define instance \var{instance})
  (define-syntax \var{field} (identifier-syntax (\var{name} \var{field} instance)))
  \etc{})
\codeend\antipar
The \code{open} form introduces definitions only for fields listed explicitly in \code{(\var{field} \etc{})}.
If the optional \var{prefix} identifier is supplied, \code{open} produces
a definition for \code{\var{prefix}\var{field}} rather than \var{field} for
each \var{field} specified.

% ----------------------------------------------------------------------------
\index{tuple!copy@\code{copy}}
\begin{syntax}
  \code{(\var{name} copy \var{instance} [\var{field} \var{value}] \etc{})}
\end{syntax}
\returns{} a new instance of tuple type \var{name} with \var{field} =
\var{value} \etc{} and remaining fields copied from \var{instance}

The \code{copy} form creates a copy of \var{instance} except that
each specified \var{field} is set to the associated \var{value}. If
$r$ = \var{instance} is not a tuple of type \var{name}, exception
\code{\#(bad-tuple \var{name} $r$ \var{src})} is raised, where
\var{src} is the source location of the \code{copy} form if
avalable.  \var{field} bindings may appear in any order.

% ----------------------------------------------------------------------------
\index{tuple!copy*@\code{copy*}}
\begin{syntax}
  \code{(\var{name} copy* \var{instance} [\var{field} \var{value}] \etc{})}
\end{syntax}
\returns{} a new instance of tuple type \var{name} with \var{field} =
\var{value} \etc{} and remaining fields copied from \var{instance}

The \code{copy*} form is like \code{copy} except that, within the \var{value} expressions,
each specified \var{field} is bound to an identifier macro that returns the value of \var{instance.field}.
If $r$ = \var{instance} is not a tuple of type \var{name}, exception
\code{\#(bad-tuple \var{name} $r$ \var{src})} is raised, where
\var{src} is the source location of the \code{copy*} form if avalable.
The \code{copy*} form is equivalent to the following, except that it
checks the tuple type only once:
\antipar\codebegin
(let ([instance \var{instance}])
  (\var{name} open instance (\var{field} \etc{}))
  (\var{name} copy instance [\var{field} \var{value}] \etc{}))
\codeend\antipar

% ----------------------------------------------------------------------------
\index{tuple!is?@\code{is?}}
\begin{syntax}
  \code{(\var{name} is? \var{x})}
\end{syntax}
\returns{} a boolean

The \code{is?} form determines whether or not the datum \var{x} is
an instance of tuple type \var{name}.

% ----------------------------------------------------------------------------
\subsection {I/O}

% ----------------------------------------------------------------------------
\defineentry{binary->utf8}
\begin{procedure}
  \code{(binary->utf8 \var{bp})}
\end{procedure}
\returns{} a transcoded textual port wrapping \var{bp}

The \code{binary->utf8} procedure takes a binary port \var{bp} and
returns a textual port wrapping \var{bp} using
\code{transcoded-port} and \code{(make-utf8-transcoder)}. The
original port \var{bp} is marked closed so that it cannot be used
except through the associated textual port.

% ----------------------------------------------------------------------------
\defineentry{close-osi-port}
\begin{procedure}
  \code{(close-osi-port \var{port})}
\end{procedure}
\returns{} unspecified

The \code{close-osi-port} procedure closes osi-port \var{port} using
\code{osi\_close\_port}. If \var{port} has already been closed,
\code{close-osi-port} does nothing.

% ----------------------------------------------------------------------------
\defineentry{close-path-watcher}
\begin{procedure}
  \code{(close-path-watcher \var{watcher})}
\end{procedure}
\returns{} unspecified

The \code{close-path-watcher} procedure uses
\code{osi\_close\_path\_watcher} to close the given path
\var{watcher}\index{path watcher}. If \var{watcher} is not a path
watcher, exception \code{\#(bad-arg close-path-watcher \var{watcher})}
is raised. If \var{watcher} has already been closed,
\code{close-path-watcher} does nothing.

% ----------------------------------------------------------------------------
\defineentry{close-tcp-listener}
\begin{procedure}
  \code{(close-tcp-listener \var{listener})}
\end{procedure}
\returns{} unspecified

The \code{close-tcp-listener} procedure closes a TCP
\var{listener}\index{TCP listener} using
\code{osi\_close\_tcp\_listener}.  If \var{listener} is not a TCP
listener, exception \code{\#(bad-arg close-tcp-listener
  \var{listener})} is raised. If \var{listener} has already been
closed, \code{close-tcp-listener} does nothing.

% ----------------------------------------------------------------------------
\defineentry{connect-tcp}
\begin{procedure}
  \code{(connect-tcp \var{hostname} \var{port-spec})}
\end{procedure}
\returns{} two values: a binary input port and a binary output port

The \code{connect-tcp} procedure calls \code{osi\_connect\_tcp} and
blocks while the TCP connection to \var{hostname} on \var{port-spec}
is established or fails to be established.  The \var{port-spec} may be
a port number or a string service name such as ``http''. The procedure
returns a custom binary input port that reads from the new connection
and a custom binary output port that writes to the new
connection. These ports do not track or report position, and the
underlying osi-ports are registered with the osi-port
guardian\index{osi-port guardian}.


If \code{osi\_connect\_tcp} fails with error pair \code{(\var{who}
  . \var{errno})}, exception \code{\#(io-error
  "[\var{hostname}]:\var{port-spec}" \var{who} \var{errno})} is
raised.  If \var{hostname} is not a string, exception \code{\#(bad-arg
  connect-tcp \var{hostname})} is raised. If \var{port-spec} is not a
fixnum between 0 and 65535 inclusive or a string, exception
\code{\#(bad-arg connect-tcp \var{port-spec})} is raised.

% ----------------------------------------------------------------------------
\defineentry{directory?}
\begin{procedure}
  \code{(directory? \var{path})}
\end{procedure}
\returns{} a boolean

The \code{directory?} procedure calls \code{(get-stat \var{path})} to
determine whether or not \var{path} is a directory.

% ----------------------------------------------------------------------------
\defineentry{force-close-output-port}
\begin{procedure}
  \code{(force-close-output-port \var{op})}
\end{procedure}
\returns{} unspecified

The \code{force-close-output-port} procedure is used to close an
output port, even if it has unflushed output that would otherwise
cause it to fail to close.  If \var{op} is not already closed,
\code{force-close-output-port} tries to close it with
\code{(close-output-port \var{op})}. If it fails, the output buffer is
cleared with \code{(clear-output-port \var{op})}, and
\code{(close-output-port \var{op})} is called again.

% ----------------------------------------------------------------------------
\defineentry{get-datum/annotations-all}
\begin{procedure}
  \code{(get-datum/annotations-all \var{ip} \var{sfd} \var{bfp})}
\end{procedure}
\returns{} a list of annotated objects

The \code{get-datum/annotations-all} procedure takes a textual input
port \var{ip}, a source-file descriptor \var{sfd}, and an exact
nonnegative integer \var{bfp} representing the character position of
the next character to be read from \var{ip}. The procedure returns a
list of the annotated objects, in order, obtained by repeatedly
calling \code{get-datum/annotations} with the advancing \var{bfp},
until \var{ip} reaches the end of file.

% ----------------------------------------------------------------------------
\defineentry{get-file-size}
\begin{procedure}
  \code{(get-file-size \var{port})}
\end{procedure}
\returns{} the number of bytes in the file associated with osi-port \var{port}

The \code{get-file-size} procedure calls \code{osi\_get\_file\_size}
to return the number of bytes in the file associated with osi-port
\var{port}.

If \code{osi\_get\_file\_size} fails with error pair \code{(\var{who}
  . \var{errno})}, exception \code{\#(io-error \var{filename}
  \var{who} \var{errno})} is raised.

% ----------------------------------------------------------------------------
\defineentry{get-real-path}
\begin{procedure}
  \code{(get-real-path \var{path})}
\end{procedure}
\returns{} the canonicalized absolute pathname of \var{path}

The \code{get-real-path} procedure calls \code{osi\_get\_real\_path}
and returns the canonicalized absolute pathname of \var{path}.

% ----------------------------------------------------------------------------
\defineentry{get-source-offset}
\begin{procedure}
  \code{(get-source-offset \var{ip})}
\end{procedure}
\returns{} an exact nonnegative integer

The \code{get-source-offset} procedure takes a binary input port
\var{ip} that supports \code{port-position}, skips over the
\code{\#!\var{interpreter-directive}} line, if any, and returns the
resulting \code{port-position}.

% ----------------------------------------------------------------------------
\defineentry{get-stat}
\begin{procedure}
  \code{(get-stat \var{path} \opt{\var{follow?}})}
\end{procedure}
\returns{} a \code{<stat>} tuple

The \code{get-stat} procedure calls \code{osi\_get\_stat} and returns
the \code{<stat>} tuple for \var{path}, following a symbolic link
unless \var{follow?} is \code{\#f}. If \code{osi\_get\_stat} fails
with error pair \code{(\var{who} . \var{errno})}, exception
\code{\#(io-error \var{path} \var{who} \var{errno})} is raised.

% ----------------------------------------------------------------------------
\defineentry{hook-console-input}
\begin{procedure}
  \code{(hook-console-input)}
\end{procedure}
\returns{} unspecified

The \code{hook-console-input} procedure replaces the system console
input port, which uses synchronous I/O, with a custom textual input
port that uses asynchronous I/O. It builds a custom binary input port
with \code{osi\_get\_stdin}, wraps it with \code{binary->utf8}, and
sets the result as the \code{console-input-port},
\code{current-input-port}, and the system internal
\code{\$console-input-port}. It does nothing after it has been called
once.

% ----------------------------------------------------------------------------
\defineentry{io-error}
\begin{procedure}
  \code{(io-error \var{name} \var{who} \var{errno})}
\end{procedure}
\returns{} never

The \code{io-error} procedure raises exception \code{\#(io-error
  \var{name} \var{who} \var{errno})}.  The string \var{name}
identifies the port.  The symbol \var{who} specifies the procedure
that raised an error, and the number \var{errno} specifies the error
code.  The \code{read-osi-port} procedure raises this exception with
\var{who}=\code{osi\_read\_port}, and the \code{write-osi-port}
procedure raises it with \var{who}=\code{osi\_write\_port}.

% ----------------------------------------------------------------------------
\defineentry{list-directory}
\begin{procedure}
  \code{(list-directory \var{path})}
\end{procedure}
\returns{} \code{((\var{name} . \var{type}) \etc)}

The \code{list-directory} procedure calls \code{osi\_list\_directory}
and returns \code{((\var{name} . \var{type}) \etc)}, the list of
directory entries of \var{path}. It does not include ``.'' and
``..''. \var{name} is the string name of the directory entry, and
\var{type} is one of the following constants:

\begin{tabular}{lllll}
\code{DIRENT\_UNKNOWN}&
\code{DIRENT\_FILE}&
\code{DIRENT\_DIR}&
\code{DIRENT\_LINK}&
\code{DIRENT\_FIFO}\\
\code{DIRENT\_SOCKET}&
\code{DIRENT\_CHAR}&
\code{DIRENT\_BLOCK}
\end{tabular}

If \code{osi\_list\_directory} fails with error pair \code{(\var{who}
  . \var{errno})}, exception \code{\#(io-error \var{path} \var{who}
  \var{errno})} is raised.

% ----------------------------------------------------------------------------
\defineentry{listen-tcp}
\begin{procedure}
  \code{(listen-tcp \var{address} \var{port-number} \var{process})}
\end{procedure}
\returns{} a TCP listener\index{TCP listener}

The \code{listen-tcp} procedure calls \code{osi\_listen\_tcp} to
create a TCP listener on the given \var{address} and \var{port-number}
and returns a TCP listener that is registered with the listener
guardian\index{listener guardian}.

For each accepted connection, the message \code{\#(accept-tcp
  \var{listener} \var{ip} \var{op})} is sent to \var{process}, where
\var{ip} is the binary input port and \var{op} is the binary output
port.

For each failed connection, the message \code{\#(accept-tcp-failed
  \var{listener} \var{who} \var{errno})} is sent to \var{process},
where \var{who} and \var{errno} specify the error.

The \var{address} is a dotted quad IPv4 address or an IPv6
address. Use \code{"::"} to listen on all IPv4 and IPv6 interfaces.
Use \code{"0.0.0.0"} to listen on all IPv4 interfaces. Otherwise, it
listens on the given \var{address} only. If \var{address} is not a
string, exception \code{\#(bad-arg listen-tcp \var{address})} is
raised.

If \var{port-number} is zero, the operating system will choose an
available port number, which can be queried with
\code{listener-port-number}. If \var{port-number} is not a fixnum
between 0 and 65535 inclusive, exception \code{\#(bad-arg listen-tcp
  \var{port-number})} is raised.

If \code{osi\_listen\_tcp} fails with error pair \code{(\var{who}
  . \var{errno})}, exception \code{\#(listen-tcp-failed \var{address}
  \var{port-number} \var{who} \var{errno})} is raised.

% ----------------------------------------------------------------------------
\defineentry{listener-address}
\begin{procedure}
  \code{(listener-address \var{listener})}
\end{procedure}
\returns{} the \code{address} field of \var{listener}

The \code{listener-address} procedure returns the \code{address} of
the given TCP \var{listener}\index{TCP listener}.

% ----------------------------------------------------------------------------
\defineentry{listener-create-time}
\begin{procedure}
  \code{(listener-create-time \var{listener})}
\end{procedure}
\returns{} a clock time in milliseconds

The \code{listener-create-time} procedure returns the clock time from
\code{erlang:now} when the given TCP \var{listener}\index{TCP
  listener} was created.

% ----------------------------------------------------------------------------
\defineentry{listener-port-number}
\begin{procedure}
  \code{(listener-port-number \var{listener})}
\end{procedure}
\returns{} the \code{port-number} field of \var{listener}

The \code{listener-port-number} procedure returns the
\code{port-number} of the given TCP \var{listener}\index{TCP
  listener}.

% ----------------------------------------------------------------------------
\defineentry{listener?}
\begin{procedure}
  \code{(listener? \var{x})}
\end{procedure}
\returns{} a boolean

The \code{listener?} procedure determines whether or not the datum
\var{x} is a TCP listener\index{TCP listener}.

% ----------------------------------------------------------------------------
\defineentry{make-directory}
\begin{procedure}
  \code{(make-directory \var{path} \opt{\var{mode}})}
\end{procedure}
\returns{} unspecified

The \code{make-directory} procedure calls \code{osi\_make\_directory}
to make directory \var{path} with \var{mode}, which defaults to
\code{\#o777}.

If \code{osi\_make\_directory} fails with error pair \code{(\var{who}
  . \var{errno})}, exception \code{\#(io-error \var{path} \var{who}
  \var{errno})} is raised.

% ----------------------------------------------------------------------------
\defineentry{make-directory-path}
\begin{procedure}
  \code{(make-directory-path \var{path} \opt{\var{mode}})}
\end{procedure}
\returns{} \var{path}

The \code{make-directory-path} procedure creates directories as needed
for the file \var{path} using \var{mode}, which defaults to
\code{\#o777}. It returns \var{path}.

% ----------------------------------------------------------------------------
\defineentry{make-osi-input-port}
\begin{procedure}
  \code{(make-osi-input-port \var{p})}
\end{procedure}
\returns{} a binary input port

The \code{make-osi-input-port} procedure returns a custom binary input
port that reads from osi-port \var{p}. It does not track position.

% ----------------------------------------------------------------------------
\defineentry{make-osi-output-port}
\begin{procedure}
  \code{(make-osi-output-port \var{p})}
\end{procedure}
\returns{} a binary output port

The \code{make-osi-output-port} procedure returns a custom binary
output port that writes to osi-port \var{p}. It does not track
position.

% ----------------------------------------------------------------------------
\defineentry{make-utf8-transcoder}
\begin{procedure}
  \code{(make-utf8-transcoder)}
\end{procedure}
\returns{} a UTF-8 transcoder

The \code{make-utf8-transcoder} procedure creates a UTF-8 transcoder
with end-of-line style \code{none} and error-handling mode
\code{replace}.

% ----------------------------------------------------------------------------
\defineentry{open-fd-port}
\begin{procedure}
  \code{(open-fd-port \var{name} \var{fd} \var{close?})}
\end{procedure}
\returns{} an osi-port

The \code{open-fd-port} procedure creates an osi-port with the given
\var{name} by calling \code{osi\_open\_fd} with \var{fd} and
\var{close?}. The osi-port is registered with the osi-port
guardian\index{osi-port guardian}.

% ----------------------------------------------------------------------------
\defineentry{open-file}
\begin{procedure}
  \code{(open-file \var{name} \var{flags} \var{mode} \var{type})}
\end{procedure}
\returns{} a custom file port

The \code{open-file} procedure creates a custom file port by calling
\code{(open-file-port \var{name} \var{flags} \var{mode})}. The custom
port supports both getting and setting the file position, except when
\var{type}=\code{append}. The particular type of custom port returned
is determined by \var{type}:
\begin{itemize}
  \item \code{binary-input}: a binary input port
  \item \code{binary-output}: a binary output port
  \item \code{input}: a textual input port wrapping a binary input
    port with \code{binary->utf8}
  \item \code{output}: a textual output port wrapping a binary
    output port with \code{binary->utf8}
  \item \code{append}: a textual output port wrapping a binary output
    port with \code{binary->utf8}. Each write appends to the file by
    specifying position $-1$.
\end{itemize}

If \var{type} is any other value, exception \code{\#(bad-arg
  open-file \var{type})} is raised.

% ----------------------------------------------------------------------------
\defineentry{open-file-port}
\begin{procedure}
  \code{(open-file-port \var{name} \var{flags} \var{mode})}
\end{procedure}
\returns{} an osi-port

The \code{open-file-port} procedure creates an osi-port by calling
\code{osi\_open\_file} with \var{name}, \var{flags}, and \var{mode}.
The osi-port is registered with the osi-port guardian\index{osi-port
  guardian}.

The following constants are defined for \var{flags}:

\begin{tabular}{llllll}
  \code{O\_APPEND}&
  \code{O\_CREAT}&
  \code{O\_DIRECT}&
  \code{O\_DIRECTORY}&
  \code{O\_DSYNC}&
  \code{O\_EXCL}\\
  \code{O\_EXLOCK}&
  \code{O\_NOATIME}&
  \code{O\_NOCTTY}&
  \code{O\_NOFOLLOW}&
  \code{O\_NONBLOCK}&
  \code{O\_RANDOM}\\
  \code{O\_RDONLY}&
  \code{O\_RDWR}&
  \code{O\_SEQUENTIAL}&
  \code{O\_SHORT\_LIVED}&
  \code{O\_SYMLINK}&
  \code{O\_SYNC}\\
  \code{O\_TEMPORARY}&
  \code{O\_TRUNC}&
  \code{O\_WRONLY}\\
\end{tabular}

The following constants are defined for \var{mode}:

\begin{tabular}{llllllll}
  \code{S\_IFMT}&
  \code{S\_IFIFO}&
  \code{S\_IFCHR}&
  \code{S\_IFDIR}&
  \code{S\_IFBLK}&
  \code{S\_IFREG}&
  \code{S\_IFLNK}&
  \code{S\_IFSOCK}\\
\end{tabular}

If \code{osi\_open\_file} fails with error pair \code{(\var{who}
  . \var{errno})}, exception \code{\#(io-error \var{name} \var{who}
  \var{errno})} is raised.

% ----------------------------------------------------------------------------
\defineentry{open-file-to-append}
\begin{procedure}
  \code{(open-file-to-append \var{name})}
\end{procedure}
\returns{} a textual file port

The \code{open-file-to-append} procedure calls\\
\code{(open-file \var{name} (+ O\_WRONLY O\_CREAT O\_APPEND) \#o777 'append)}.

% ----------------------------------------------------------------------------
\defineentry{open-file-to-read}
\begin{procedure}
  \code{(open-file-to-read \var{name})}
\end{procedure}
\returns{} a textual file port

The \code{open-file-to-read} procedure calls \code{(open-file
  \var{name} O\_RDONLY 0 'input)}.

% ----------------------------------------------------------------------------
\defineentry{open-file-to-replace}
\begin{procedure}
  \code{(open-file-to-replace \var{name})}
\end{procedure}
\returns{} a textual file port

The \code{open-file-to-replace} procedure calls\\
\code{(open-file \var{name} (+ O\_WRONLY O\_CREAT O\_TRUNC) \#o777 'output)}.

% ----------------------------------------------------------------------------
\defineentry{open-file-to-write}
\begin{procedure}
  \code{(open-file-to-write \var{name})}
\end{procedure}
\returns{} a custom file port

The \code{open-file-to-write} procedure calls\\
\code{(open-file \var{name} (+ O\_WRONLY O\_CREAT O\_EXCL) \#o777 'output)}.

% ----------------------------------------------------------------------------
\defineentry{open-utf8-bytevector}
\begin{procedure}
  \code{(open-utf8-bytevector \var{bv})}
\end{procedure}
\returns{} a transcoded textual input port wrapping \var{bv}

The \code{open-utf8-bytevector} procedure calls
\code{(binary->utf8 (open-bytevector-input-port \var{bv}))}.

% ----------------------------------------------------------------------------
\defineentry{osi-port-count}
\begin{procedure}
  \code{(osi-port-count)}
\end{procedure}
\returns{} the number of open osi-ports

The \code{osi-port-count} procedure returns the number of open
osi-ports.

% ----------------------------------------------------------------------------
\defineentry{osi-port-create-time}
\begin{procedure}
  \code{(osi-port-create-time \var{p})}
\end{procedure}
\returns{} a clock time in milliseconds

The \code{osi-port-create-time} procedure returns the clock time from
\code{erlang:now} when the osi-port \var{p} was created.

% ----------------------------------------------------------------------------
\defineentry{osi-port-name}
\begin{procedure}
  \code{(osi-port-name \var{p})}
\end{procedure}
\returns{} a string

The \code{osi-port-name} procedure returns the name of osi-port
\var{p}.

% ----------------------------------------------------------------------------
\defineentry{osi-port?}
\begin{procedure}
  \code{(osi-port? \var{x})}
\end{procedure}
\returns{} a boolean

The \code{osi-port?} procedure determines whether or not the datum
\var{x} is an osi-port.

% ----------------------------------------------------------------------------
\defineentry{path-combine}
\begin{procedure}
  \code{(path-combine \var{path$_1$} \var{path$_2$} \etc{})}
\end{procedure}
\returns{} the string combining the paths

The \code{path-combine} procedure appends one or more paths, inserting
the directory-separator character between each pair of paths as
needed.

% ----------------------------------------------------------------------------
\defineentry{path-watcher-count}
\begin{procedure}
  \code{(path-watcher-count)}
\end{procedure}
\returns{} the number of open path watchers

The \code{path-watcher-count} procedure returns the number of open
path watchers\index{path watcher}.

% ----------------------------------------------------------------------------
\defineentry{path-watcher-create-time}
\begin{procedure}
  \code{(path-watcher-create-time \var{watcher})}
\end{procedure}
\returns{} a clock time in milliseconds

The \code{path-watcher-create-time} procedure returns the clock time
from \code{erlang:now} when the given path \var{watcher}\index{path
  watcher} was created.

% ----------------------------------------------------------------------------
\defineentry{path-watcher-path}
\begin{procedure}
  \code{(path-watcher-path \var{watcher})}
\end{procedure}
\returns{} the \code{path} field of \var{watcher}

The \code{path-watcher-path} procedure returns the \code{path} of the
given path \var{watcher}\index{path watcher}.

% ----------------------------------------------------------------------------
\defineentry{path-watcher?}
\begin{procedure}
  \code{(path-watcher? \var{x})}
\end{procedure}
\returns{} a boolean

The \code{path-watcher?} procedure determines whether or not the datum
\var{x} is a path watcher.

% ----------------------------------------------------------------------------
\defineentry{print-osi-ports}
\begin{procedure}
  \code{(print-osi-ports \opt{\var{op}})}
\end{procedure}
\returns{} unspecified

The \code{print-osi-ports} procedure prints information about all open
osi-ports to textual output port \var{op}, which defaults to the
current output port.

% ----------------------------------------------------------------------------
\defineentry{print-path-watchers}
\begin{procedure}
  \code{(print-path-watchers \opt{\var{op}})}
\end{procedure}
\returns{} unspecified

The \code{print-path-watchers} procedure prints information about all
open path watchers\index{path watcher} to textual output port
\var{op}, which defaults to the current output port.

% ----------------------------------------------------------------------------
\defineentry{print-tcp-listeners}
\begin{procedure}
  \code{(print-tcp-listeners \opt{\var{op}})}
\end{procedure}
\returns{} unspecified

The \code{print-tcp-listeners} procedure prints information about all
open TCP listeners\index{TCP listener} to textual output port
\var{op}, which defaults to the current output port.

% ----------------------------------------------------------------------------
\defineentry{read-bytevector}
\begin{procedure}
  \code{(read-bytevector \var{name} \var{contents})}
\end{procedure}
\returns{} a list of annotations

The \code{read-bytevector} procedure takes a filename \var{name} and
\var{contents} bytevector and returns a list of annotations read using
\code{get-datum/annotations} from the \var{contents} bytevector
transcoded with \code{(make-utf8-transcoder)}.

% ----------------------------------------------------------------------------
\defineentry{read-file}
\begin{procedure}
  \code{(read-file \var{name})}
\end{procedure}
\returns{} a bytevector with the contents of \var{name}

The \code{read-file} procedure calls \code{(open-file-port \var{name}
  O\_RDONLY 0)} to open the file \var{name} and returns the contents
as a bytevector.

% ----------------------------------------------------------------------------
\defineentry{read-osi-port}
\begin{procedure}
  \code{(read-osi-port \var{port} \var{bv} \var{start} \var{n} \var{fp})}
\end{procedure}
\returns{} the number of bytes read

The \code{read-osi-port} procedure calls \code{osi\_read\_port} with
the handle from the given osi-port \var{port}, bytevector buffer
\var{bv}, starting 0-based buffer index \var{start}, maximum number of
bytes to read \var{n}, and starting 0-based file position \var{fp}. To
specify the current position, use \var{fp}=$-1$. The calling process
blocks for the I/O to complete. If the read fails with error pair
\code{(\var{who} . \var{errno})}, exception \code{\#(io-error
  \var{name} \var{who} \var{errno})} is raised, where \var{name} is
the name of \var{port}. Otherwise, the number of bytes read is
returned. Error code UV\_EOF (end of file) is not considered an error,
and 0 is returned.

% ----------------------------------------------------------------------------
\defineentry{regular-file?}
\begin{procedure}
  \code{(regular-file? \var{path})}
\end{procedure}
\returns{} a boolean

The \code{regular-file?} procedure calls \code{(get-stat \var{path})}
to determine whether or not \var{path} is a regular file.

% ----------------------------------------------------------------------------
\defineentry{remove-directory}
\begin{procedure}
  \code{(remove-directory \var{path})}
\end{procedure}
\returns{} unspecified

The \code{remove-directory} procedure calls
\code{osi\_remove\_directory} to remove directory \var{path}.

If \code{osi\_remove\_directory} fails with error pair
\code{(\var{who} . \var{errno})}, exception \code{\#(io-error
  \var{path} \var{who} \var{errno})} is raised.

% ----------------------------------------------------------------------------
\defineentry{remove-file}
\begin{procedure}
  \code{(remove-file \var{path})}
\end{procedure}
\returns{} unspecified

The \code{remove-file} procedure calls \code{osi\_unlink} to remove
file \var{path}.

If \code{osi\_unlink} fails with error pair \code{(\var{who}
  . \var{errno})}, exception \code{\#(io-error \var{path} \var{who}
  \var{errno})} is raised.

% ----------------------------------------------------------------------------
\defineentry{rename-path}
\begin{procedure}
  \code{(rename-path \var{path} \var{new-path})}
\end{procedure}
\returns{} unspecified

The \code{rename-path} procedure calls \code{osi\_rename} to rename
\var{path} to \var{new-path}.

If \code{osi\_rename} fails with error pair \code{(\var{who}
  . \var{errno})}, exception \code{\#(io-error \var{path} \var{who}
  \var{errno})} is raised.

% ----------------------------------------------------------------------------
\defineentry{set-file-mode}
\begin{procedure}
  \code{(set-file-mode \var{path} \var{mode})}
\end{procedure}
\returns{} unspecified

The \code{set-file-mode} procedure calls \code{osi\_chmod} to set the
file mode of \var{path} to \var{mode}.

If \code{osi\_chmod} fails with error pair \code{(\var{who}
  . \var{errno})}, exception \code{\#(io-error \var{path} \var{who}
  \var{errno})} is raised.

% ----------------------------------------------------------------------------
\defineentry{spawn-os-process}
\begin{procedure}
  \code{(spawn-os-process \var{path} \var{args} \var{process})}
\end{procedure}
\returns{} four values: a binary output port \var{to-stdin}, a binary
input port \var{from-stdout}, a binary input port \var{from-stderr},
and an integer process identifier \var{os-pid}

The \code{spawn-os-process} procedure calls \code{osi\_spawn} to spawn
an operating system process with the string \var{path} and list of
string-valued \var{args}. It returns a custom binary output port
\var{to-stdin} that writes to the standard input of the process,
custom binary input ports \var{from-stdout} and \var{from-stderr} that
read from the standard output and standard error of the process,
respectively, and a process identifier \var{os-pid}. These ports do
not track or report position, and the underlying osi-ports are
registered with the osi-port guardian\index{osi-port guardian}.

When the spawned process terminates, \code{\#(process-terminated
  \var{os-pid} \var{exit-status} \var{term-signal})} is sent to
\var{process}.

If \code{osi\_spawn} returns error pair \code{(\var{who}
  . \var{errno})}, exception \code{\#(io-error \var{path} \var{who}
  \var{errno})} is raised.

% ----------------------------------------------------------------------------
\defineentry{stat-directory?}
\begin{procedure}
  \code{(stat-directory? \var{x})}
\end{procedure}
\returns{} a boolean

The \code{stat-directory?} procedure determines whether or not the
datum \var{x} is a \code{<stat>} tuple for a directory.

% ----------------------------------------------------------------------------
\defineentry{stat-regular-file?}
\begin{procedure}
  \code{(stat-regular-file? \var{x})}
\end{procedure}
\returns{} a boolean

The \code{stat-regular-file?} procedure determines whether or not the
datum \var{x} is a \code{<stat>} tuple for a regular file.

% ----------------------------------------------------------------------------
\defineentry{tcp-listener-count}
\begin{procedure}
  \code{(tcp-listener-count)}
\end{procedure}
\returns{} the number of open TCP listeners

The \code{tcp-listener-count} procedure returns the number of open TCP
listeners\index{TCP listener}.

% ----------------------------------------------------------------------------
\defineentry{watch-path}
\begin{procedure}
  \code{(watch-path \var{path} \var{process})}
\end{procedure}
\returns{} a path watcher\index{path watcher}

The \code{watch-path} procedure calls \code{osi\_watch\_path} to track
changes to \var{path} and returns a path watcher that is registered
with the path-watcher guardian\index{path-watcher guardian}.

Every time a change is detected, \code{\#(path-changed \var{path}
  \var{filename} \var{events})} is sent to \var{process}, where
\var{events} is 1 for rename, 2 for change, and 3 for rename and
change. If the watcher encounters an error,
\code{\#(path-watcher-failed \var{path} \var{errno})} is sent to
\var{process}.

If \code{osi\_watch\_path} returns error pair \code{(\var{who}
  . \var{errno})}, exception \code{\#(io-error \var{path} \var{who}
  \var{errno})} is raised.

% ----------------------------------------------------------------------------
\defineentry{with-sfd-source-offset}
\begin{procedure}
  \code{(with-sfd-source-offset \var{name} \var{handler})}
\end{procedure}
\returns{} see below

The \code{with-sfd-source-offset} procedure takes a filename
\var{name} and returns the result of calling the procedure
\var{handler} with three arguments: \var{ip}, a textual port
transcoded with \code{(make-utf8-transcoder)}, \var{sfd}, a
source-file descriptor that refers to \var{name}, and
\var{source-offset}, the value returned by \code{get-source-offset}.
Before returning, \code{with-sfd-source-offset} closes the textual
port.

% ----------------------------------------------------------------------------
\defineentry{write-osi-port}
\begin{procedure}
  \code{(write-osi-port \var{port} \var{bv} \var{start} \var{n} \var{fp})}
\end{procedure}
\returns{} the number of bytes written

The \code{write-osi-port} procedure calls \code{osi\_write\_port} with
the handle from the given osi-port \var{port}, bytevector buffer
\var{bv}, starting 0-based buffer index \var{start}, maximum number of
bytes to write \var{n}, and starting 0-based file position
\var{fp}. To specify the current position, use \var{fp}=$-1$. The
calling process blocks for the I/O to complete. If the write fails
with error pair \code{(\var{who} . \var{errno})}, exception
\code{\#(io-error \var{name} \var{who} \var{errno})} is raised, where
\var{name} is the name of \var{port}. Otherwise, the number of bytes
written is returned.

% ----------------------------------------------------------------------------
\subsection {Queues}

A queue is represented as a pair of lists,
\code{(\var{in}~.~\var{out})}. The \var{out} list contains the first
elements of the queue, and the \var{in} list contains the last
elements of the queue in reverse. This representation allows for O(1)
amortized insertion and removal times. The implementation is based on
the Erlang queue module~\cite{queue-ref}.

% ----------------------------------------------------------------------------
\defineentry{queue:add}
\begin{procedure}
  \code{(queue:add \var{x} \var{q})}
\end{procedure}
\returns{} a queue that adds \var{x} to the rear of \var{q}

% ----------------------------------------------------------------------------
\defineentry{queue:add-front}
\begin{procedure}
  \code{(queue:add-front \var{x} \var{q})}
\end{procedure}
\returns{} a queue that adds \var{x} to the front of \var{q}

% ----------------------------------------------------------------------------
\defineentry{queue:drop}
\begin{procedure}
  \code{(queue:drop \var{q})}
\end{procedure}
\returns{} a queue without the first element of \var{q}

% ----------------------------------------------------------------------------
\defineentry{queue:empty}
\begin{syntax}
  \code{queue:empty}
\end{syntax}
\returns{} the empty queue

% ----------------------------------------------------------------------------
\defineentry{queue:empty?}
\begin{procedure}
  \code{(queue:empty? \var{q})}
\end{procedure}
\returns{} \code{\#t} if \var{q} is a queue, \code{\#f} otherwise

% ----------------------------------------------------------------------------
\defineentry{queue:get}
\begin{procedure}
  \code{(queue:get \var{q})}
\end{procedure}
\returns{} the first element of \var{q}

% ----------------------------------------------------------------------------
\subsection{Hash Tables}

The implementation of functional hash tables is based on the Erlang
dict module~\cite{dict-ref,dynamic-hashing}.

% ----------------------------------------------------------------------------
\defineentry{ht:delete}
\begin{procedure}
  \code{(ht:delete \var{ht} \var{key})}
\end{procedure}
\returns{} a hash table formed by dropping any association of
\var{key} from \var{ht}

% ----------------------------------------------------------------------------
\defineentry{ht:fold}
\begin{procedure}
  \code{(ht:fold \var{ht} \var{f} \var{init})}
\end{procedure}
\returns{} see below

The \code{ht:fold} procedure accumulates a value by applying \var{f}
to each key/value association in \var{ht} and the accumulator, which
is initially \var{init}. It can be defined recursively as follows,
where $n$ is the size of \var{ht}, and the result of \code{ht:fold}
is $F_n$:

$$\begin{array}{r@{\;=\;}l}
F_0 & \var{init}\\
F_i & \code{(\var{f} \var{key$_i$} \var{val$_i$} $F_{i-1}$)}
\hbox{ for $1 \le i \le n$}\\
\end{array}$$

% ----------------------------------------------------------------------------
\defineentry{ht:is?}
\begin{procedure}
  \code{(ht:is? \var{x})}
\end{procedure}
\returns{} \code{\#t} if \var{x} is a hash table, \code{\#f}
otherwise

% ----------------------------------------------------------------------------
\defineentry{ht:keys}
\begin{procedure}
  \code{(ht:keys \var{ht})}
\end{procedure}
\returns{} a list of the keys of \var{ht}

% ----------------------------------------------------------------------------
\defineentry{ht:make}
\begin{procedure}
  \code{(ht:make \var{hash-key} \var{equal-key?} \var{valid-key?})}
\end{procedure}
\returns{} an empty hash table

The \code{ht:make} procedure returns an empty hash table.

The \var{hash-key} procedure takes a key and returns an exact
integer. It must return the same integer for equivalent keys.

The \var{equal-key?} procedure takes two keys and returns a true value
if they are equivalent and \code{\#f} otherwise.

The \var{valid-key?} procedure takes a datum and returns a true value
if it a valid key and \code{\#f} otherwise.

% ----------------------------------------------------------------------------
\defineentry{ht:ref}
\begin{procedure}
  \code{(ht:ref \var{ht} \var{key} \var{default})}
\end{procedure}
\returns{} the value associated with \var{key} in \var{ht},
\var{default} if none

% ----------------------------------------------------------------------------
\defineentry{ht:set}
\begin{procedure}
  \code{(ht:set \var{ht} \var{key} \var{val})}
\end{procedure}
\returns{} a hash table formed by associating \var{key} with \var{val}
in \var{ht}

% ----------------------------------------------------------------------------
\defineentry{ht:size}
\begin{procedure}
  \code{(ht:size \var{ht})}
\end{procedure}
\returns{} the number of entries in \var{ht}

% ----------------------------------------------------------------------------
\subsection{Error Strings}

% ----------------------------------------------------------------------------
\defineentry{current-exit-reason->english}
\begin{parameter}
  \code{current-exit-reason->english}
\end{parameter}
\hasvalue{} a procedure of one argument that returns an English string

The \code{current-exit-reason->english} parameter specifies the
conversion procedure used by \code{exit-reason->english}. It defaults
to \code{swish-exit-reason->english}.

% ----------------------------------------------------------------------------
\defineentry{exit-reason->english}
\begin{procedure}
  \code{(exit-reason->english \var{x})}
\end{procedure}
\returns{} a string in U.S. English

The \code{exit-reason->english} procedure converts an exit reason into
an English string using the procedure stored in parameter
\code{current-exit-reason->english}.

% ----------------------------------------------------------------------------
\defineentry{swish-exit-reason->english}
\begin{procedure}
  \code{(swish-exit-reason->english \var{x})}
\end{procedure}
\returns{} a string in U.S. English

The \code{swish-exit-reason->english} procedure converts an exit
reason from Swish into an English string.

% ----------------------------------------------------------------------------
\subsection{String Utilities}

The string utilities below are found in the \code{(swish
  string-utils)} library. For regular expression support, see the
\code{(swish pregexp)} library described in~\cite{pregexp}.

% ----------------------------------------------------------------------------
\defineentry{ends-with?}
\begin{procedure}
  \code{(ends-with? \var{s} \var{p})}
\end{procedure}
\returns{} a boolean

The \code{ends-with?} procedure determines whether or not the string
\var{s} ends with string \var{p} using case-sensitive comparisons.

% ----------------------------------------------------------------------------
\defineentry{ends-with-ci?}
\begin{procedure}
  \code{(ends-with-ci? \var{s} \var{p})}
\end{procedure}
\returns{} a boolean

The \code{ends-with-ci?} procedure determines whether or not the
string \var{s} ends with string \var{p} using case-insensitive
comparisons.

% ----------------------------------------------------------------------------
\defineentry{format-rfc2822}
\begin{procedure}
  \code{(format-rfc2822 \var{d})}
\end{procedure}
\returns{} a string like ``Thu, 28 Jul 2016 17:20:11 -0400''

The \code{format-rfc2822} procedure returns a string representation of
the date object \var{d} in the form specified in Section 3.3 of RFC
2822~\cite{RFC2822}.

% ----------------------------------------------------------------------------
\defineentry{join}
\begin{procedure}
  \code{(join \var{ls} \var{separator} \opt{\var{last-separator}})}
\end{procedure}
\returns{} a string

The \code{join} procedure returns the string formed by displaying each
of the elements of list \var{ls} separated by displaying
\var{separator}. When \var{last-separator} is specified, it is used as
the last separator.

% ----------------------------------------------------------------------------
\defineentry{split}
\begin{procedure}
  \code{(split \var{str} \var{separator})}
\end{procedure}
\returns{} a list of strings

The \code{split} procedure divides the \var{str} string by the
\var{separator} character into a list of strings, none of which
contain \var{separator}.

% ----------------------------------------------------------------------------
\defineentry{split-n}
\begin{procedure}
  \code{(split-n \var{str} \var{separator} \var{n})}
\end{procedure}
\returns{} a list of no more than \var{n} strings

The \code{split-n} procedure divides the \var{str} string by the
\var{separator} character into a list of at most \var{n} strings. The
last string may contain \var{separator}.

% ----------------------------------------------------------------------------
\defineentry{starts-with?}
\begin{procedure}
  \code{(starts-with? \var{s} \var{p})}
\end{procedure}
\returns{} a boolean

The \code{starts-with?} procedure determines whether or not the string
\var{s} starts with string \var{p} using case-sensitive comparisons.

% ----------------------------------------------------------------------------
\defineentry{starts-with-ci?}
\begin{procedure}
  \code{(starts-with-ci? \var{s} \var{p})}
\end{procedure}
\returns{} a boolean

The \code{starts-with-ci?} procedure determines whether or not the
string \var{s} starts with string \var{p} using case-insensitive
comparisons.

% ----------------------------------------------------------------------------
\defineentry{symbol-append}
\begin{procedure}
  \code{(symbol-append . \var{ls})}
\end{procedure}
\returns{} a symbol

The \code{symbol-append} procedure returns the symbol formed by
appending the symbols passed as arguments.
